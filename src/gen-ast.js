#!/usr/bin/env node

// Generate AST nodes from data descriptions.


// -+-+-+-+-+-+-+-+ Argument Types -+-+-+-+-+-+-+-+

const type_checks = {
  'Expr':         (w,n) => `    if (!(${n} instanceof Expr)) throw new Error("${w}: argument '${n}' must be an 'Expr' node");`,
  'Text':         (w,n) => `    if (typeof ${n} !== 'string') throw new Error("${w}: argument '${n}' must be a string");`,
  'Text|no-enc':  (w,n) => `    if (typeof ${n} !== 'string') throw new Error("${w}: argument '${n}' must be a string");`,
  'Bool':         (w,n) => `    if (typeof ${n} !== 'boolean') throw new Error("${w}: argument '${n}' must be a boolean");`,
  'Number':       (w,n) => `    if (typeof ${n} !== 'number') throw new Error("${w}: argument '${n}' must be a number");`,
  'List|Text|NE': (w,n) => `    if (!(${n} instanceof Array)) throw new Error("${w}: argument '${n}' must be an array of strings");\n    for (var _a=0; _a<${n}.length; _a++) if (typeof ${n}[_a] !== 'string') throw new Error("${w}: argument '${n}' (index "+_a+") must be a string");`,
  'List|Expr|NE': (w,n) => `    if (!(${n} instanceof Array)) throw new Error("${w}: argument '${n}' must be an array of 'Expr' nodes");\n    for (var _a=0; _a<${n}.length; _a++) if (!(${n}[_a] instanceof Expr)) throw new Error("${w}: argument '${n}' (index "+_a+") must be an 'Expr' node");`,
  'List|Attr':    (w,n) => `    if (!(${n} instanceof Array)) throw new Error("${w}: argument '${n}' must be an array of 'Attr' nodes");\n    for (var _a=0; _a<${n}.length; _a++) if (!(${n}[_a] instanceof Attr)) throw new Error("${w}: argument '${n}' (index "+_a+") must be an 'Attr' node");`,
  'List|Attr|PR': (w,n) => `    if (!(${n} instanceof Array)) throw new Error("${w}: argument '${n}' must be an array of 'Attr' nodes");\n    for (var _a=0; _a<${n}.length; _a++) if (!(${n}[_a] instanceof Attr)) throw new Error("${w}: argument '${n}' (index "+_a+") must be an 'Attr' node");`,
  'List|DOM':     (w,n) => `    if (!(${n} instanceof Array)) throw new Error("${w}: argument '${n}' must be an array of 'DOM' nodes");\n    for (var _a=0; _a<${n}.length; _a++) if (!(${n}[_a] instanceof DOM)) throw new Error("${w}: argument '${n}' (index "+_a+") must be a 'DOM' node");`,
  'List|DOM|IN':  (w,n) => `    if (!(${n} instanceof Array)) throw new Error("${w}: argument '${n}' must be an array of 'DOM' nodes");\n    for (var _a=0; _a<${n}.length; _a++) if (!(${n}[_a] instanceof DOM)) throw new Error("${w}: argument '${n}' (index "+_a+") must be a 'DOM' node");`,
};

const encoders = {
  'Expr':         n => `    this.${n}.encode(tpl);`,
  'Text':         n => `    tpl.push(sym(this.${n}));`,
  'Text|no-enc':  n => '',
  'Bool':         n => `    tpl.push(this.${n} ? 1 : 0);`,
  'Number':       n => `    tpl.push(this.${n});`,
  'List|Text|NE': n => `    tpl.push(this.${n}.length); tpl.push.apply(tpl, this.${n}.map(sym));`,
  'List|Expr|NE': n => `    tpl.push(this.${n}.length); this.${n}.forEach(n => n.encode(tpl));`,
  'List|Attr':    n => `    tpl.push(this.${n}.length); this.${n}.forEach(n => n.encode(tpl));`,
  'List|Attr|PR': n => `    encode_named_nodes(tpl, this.${n});`,
  'List|DOM':     n => `    tpl.push(this.${n}.length); this.${n}.forEach(n => n.encode(tpl));`,
  'List|DOM|IN':  n => `    encode_inline(tpl, this.${n});`,
};


// -+-+-+-+-+-+-+-+ Generator -+-+-+-+-+-+-+-+

function gen_oper(ord, _name, base, oper, _args) {
  return `    ${oper}: ${ord},`;
}

function gen_enum(base, name, ops) {
  const body = ops.filter(n => n[2] === base).map(n => gen_oper.apply(null, n)).join('\n');
  return `\n  var ${name} = {\n${body}\n  };`;
}

function gen_ast(bases, opcodes) {
  const log = console.log;
  const base_map = new Map(bases);

  function gen_node(ord, name, base, oper, args) {
    if (base && !base_map.get(base)) throw new Error(`unknown base '${base}' for node '${name}'`);
    args.forEach(n => { if (!type_checks[n[1]]) throw new Error(`unknown type '${n[1]}' for argument '${n[0]}'`); });
    const cargs = args.map(n => n[0]).join(', ');
    const checks = args.map(n => type_checks[n[1]](name,n[0])).join('\n');
    const assigns = args.map(n => `    this.${n[0]} = ${n[0]};`).join('\n');
    const encodes = args.map(n => encoders[n[1]](n[0])).filter(n => n).join('\n');
    const new_base = base ? `\n  ${name}.prototype = new ${base}();` : '';
    const prefix = base && base_map.get(base);
    const prefix_dot = prefix ? `${prefix}.` : '';
    return `
  function ${name}(${cargs}) {
    if (!(this instanceof ${name})) throw new Error("${name}: must use 'new' to create an instance");
${checks}
${assigns}
  }${new_base}
  ${name}.prototype.encode = function (tpl) {
    tpl.push(${prefix_dot}${oper});
${encodes}
  };
`;
  }

  log(`// generated by gen-ast.js\n`);
  log(bases.map(n => `  function ${n[0]}() {}`).join('\n'));
  log(bases.map(n => gen_enum(n[0], n[1], opcodes)).join('\n'));
  log(opcodes.map(n => gen_node.apply(null, n)).join('\n'));
}


// -+-+-+-+-+-+-+-+ Source Data -+-+-+-+-+-+-+-+

const bases = [
  ['DOM', 'dom_ops'],
  ['Attr', 'attr_ops'],
  ['Expr', 'expr_ops'],
];

const opcodes = [
  [0, 'DomText', 'DOM', 'text', [['text', 'Text']]],
  [1, 'DomBoundText', 'DOM', 'bound_text', [['expr', 'Expr']]],
  [2, 'DomTag', 'DOM', 'tag', [['name', 'Text'], ['binds', 'List|Attr'], ['contents', 'List|DOM']]],
  [3, 'DomComponent', 'DOM', 'component', [['name', 'Text|no-enc'], ['cid', 'Number'], ['binds', 'List|Attr|PR'], ['contents', 'List|DOM|IN']]],
  [4, 'CondNode', 'DOM', 'condition', [['expr', 'Expr'], ['contents', 'List|DOM|IN']]],
  [5, 'RepeatNode', 'DOM', 'repeat', [['bind_as', 'Text'], ['expr', 'Expr'], ['contents', 'List|DOM|IN']]],

  [0, 'LiteralText', 'Attr', 'literal_text', [['name', 'Text'], ['value', 'Text']]],
  [1, 'LiteralBool', 'Attr', 'literal_bool', [['name', 'Text'], ['value', 'Bool']]],
  [2, 'BoundText', 'Attr', 'bound_text', [['name', 'Text'], ['expr', 'Expr']]],
  [3, 'BoundBool', 'Attr', 'bound_bool', [['name', 'Text'], ['expr', 'Expr']]],
  [4, 'LiteralClass', 'Attr', 'literal_class', [['name', 'Text']]],
  [5, 'BoundClass', 'Attr', 'bound_class', [['expr', 'Expr']]],
  [6, 'CondClass', 'Attr', 'bound_cond_class', [['name', 'Text'], ['expr', 'Expr']]],

  [0, 'ConstText', 'Expr', 'const_text', [['text', 'Text']]],
  [1, 'ConstNum', 'Expr', 'const_num', [['value', 'Number']]],
  [2, 'ScopeLookup', 'Expr', 'scope_lookup', [['path', 'List|Text|NE']]],
  [3, 'ConcatText', 'Expr', 'concat_text', [['args', 'List|Expr|NE']]],
  [4, 'EqualsOp', 'Expr', 'equals', [['left', 'Expr'], ['right', 'Expr']]],
  [5, 'AddOp', 'Expr', 'add', [['left', 'Expr'], ['right', 'Expr']]],
  [6, 'SubOp', 'Expr', 'sub', [['left', 'Expr'], ['right', 'Expr']]],
  [7, 'MulOp', 'Expr', 'mul', [['left', 'Expr'], ['right', 'Expr']]],
  [8, 'DivOp', 'Expr', 'div', [['left', 'Expr'], ['right', 'Expr']]],
];


// -+-+-+-+-+-+-+-+ Run -+-+-+-+-+-+-+-+

gen_ast(bases, opcodes);
